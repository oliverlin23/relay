# Fusion Decoder Visualization Guide

This document explains the four visualization files generated by the fusion decoder benchmark analysis.

## Overview

The visualizations analyze the performance of **fusion decoding** with different partitioning strategies for the [[72, 12, 6]] bivariate bicycle code. Fusion decoding divides the code into partitions and decodes them separately, then combines the results. The key metric is **partition quality** - how well the code can be divided with minimal cross-partition dependencies.

---

## 1. Partition Quality (`partition_quality.png`)

This 2×2 grid compares **time-axis partitioning** vs **count-based partitioning** strategies.

### Top-Left: Boundary Ratio vs Number of Partitions
- **What it shows**: Compares both strategies when using the same number of partitions
- **X-axis**: Number of partitions
- **Y-axis**: Average boundary ratio (percentage)
- **Key insight**: Lower boundary ratio = better partitioning (fewer connections cross partition boundaries)
- **How to read**: The line that stays lower indicates the better strategy for that partition count

### Top-Right: Boundary Ratio Range (Min/Avg/Max)
- **What it shows**: Variation in partition quality across all partitions
- **X-axis**: Different partitioning strategies tested
- **Y-axis**: Boundary ratio (percentage)
- **Error bars**: Show min (bottom) to max (top), with average marked
- **Key insight**: Smaller error bars = more consistent partition quality

### Bottom-Left: Time-Axis Rounds per Partition vs Boundary Ratio
- **What it shows**: How partition quality changes as you vary rounds per partition
- **X-axis**: Rounds per partition (time-axis strategy only)
- **Y-axis**: Average boundary ratio (percentage)
- **Annotations**: Show the resulting number of partitions (e.g., "3 parts")
- **Key insight**: Helps find the optimal rounds-per-partition setting

### Bottom-Right: Best Strategy Comparison
- **What it shows**: Direct comparison of the best configuration from each strategy
- **Bars**: Best time-axis vs best count-based
- **Improvement factor**: Shows how much better one strategy is (e.g., "2.5x improvement")
- **Key insight**: Which strategy achieves the best overall partition quality

---

## 2. Decoding Performance (`decoding_performance.png`)

This visualization compares three decoders side-by-side across three key metrics.

### Left: Success Rate
- **What it measures**: Percentage of test samples decoded correctly
- **Decoders compared**:
  - **Baseline**: Standard belief propagation decoder (no partitioning)
  - **Time-axis Fusion**: Fusion decoder with time-axis partitioning
  - **Count-based Fusion**: Fusion decoder with count-based partitioning
- **Higher is better**: 100% means all samples decoded successfully

### Middle: Average Iterations
- **What it measures**: Average number of belief propagation iterations needed
- **Lower is better**: Fewer iterations = faster convergence
- **Note**: All decoders should achieve similar success rates; this shows computational efficiency

### Right: Decoding Time (or Iterations)
- **What it measures**: Wall-clock time per sample (if available), otherwise shows iterations again
- **Lower is better**: Faster decoding = better performance
- **Note**: Timing data may not always be available in benchmark output

---

## 3. Code Structure (`bb_code_structure.png`)

This two-panel visualization shows the temporal structure of the code and how it's partitioned.

### Left Panel: Rounds (first 6 of 30)
- **What it shows**: The temporal structure of the quantum error correction code
- **Each colored block**: Represents one round of error correction
- **Label format**: "Round N" with detector count (72 detectors per round)
- **Color gradient**: Indicates progression through time (darker = earlier rounds)
- **Note**: Only shows first 6 rounds as a representative sample; the full code has 30 rounds

### Right Panel: Partitions (first 3 of total)
- **What it shows**: How rounds are grouped into partitions for fusion decoding
- **Each colored block**: Represents one partition
- **Label format**: 
  - "P0: R0-9" = Partition 0 contains rounds 0-9
  - "720 dets" = 720 detectors in this partition (10 rounds × 72 detectors)
- **Color coding**: Different colors for different partitions
- **Note**: Only shows first 3 partitions as a sample; total depends on rounds-per-partition setting

---

## 4. Partition Structure (`partition_structure.png`)

This visualization shows the actual check matrix structure and how partitions divide it.

### Left Panel: Check Matrix Structure (Sample)
- **What it shows**: The sparse matrix pattern of detector-variable connections
- **Heatmap colors**:
  - **Yellow/Red**: Connected (detector checks this error variable)
  - **Dark**: Not connected
- **Blue dashed lines**: Round boundaries (every 72 detectors)
- **Sampling**: Shows first 500 detectors × 2000 variables (full matrix is 2160 × 87012)
- **Key insight**: Visualizes the sparse structure of the code and how connections are distributed

### Right Panel: Time-Axis Partitioning Visualization
- **What it shows**: Conceptual view of how partitions divide the code temporally
- **Each colored block**: One partition with its round range
- **Label format**: 
  - "Partition N"
  - "Rounds X-Y" (inclusive range)
  - Detector count
- **Shows up to 10 partitions**: For codes with more partitions, only first 10 are displayed
- **Key insight**: Shows how the temporal structure maps to partition boundaries

---

## Key Concepts

### Boundary Ratio
- **Definition**: Fraction of check matrix connections that cross partition boundaries
- **Lower is better**: Fewer cross-boundary connections = better partition quality
- **Why it matters**: Cross-boundary connections require communication between partitions, which adds overhead

### Time-Axis Partitioning
- **Strategy**: Divides rounds sequentially (e.g., rounds 0-9, 10-19, 20-29)
- **Advantage**: Respects the temporal structure of the code
- **Example**: With 10 rounds/partition on a 30-round code → 3 partitions

### Count-Based Partitioning
- **Strategy**: Divides based on detector count, not round boundaries
- **Advantage**: Can create more balanced partition sizes
- **Trade-off**: May split rounds, creating more cross-boundary connections

### Fusion Decoding
- **Process**: 
  1. Divide code into partitions
  2. Decode each partition independently
  3. Combine results across partition boundaries
- **Goal**: Reduce computational complexity by working on smaller sub-problems
- **Challenge**: Maintaining accuracy despite partition boundaries

---

## How to Use These Visualizations

1. **Start with Partition Quality**: Determine which partitioning strategy works best for your code
2. **Check Decoding Performance**: Verify that fusion decoding maintains accuracy while potentially improving speed
3. **Understand Code Structure**: Use the structure visualizations to see how your code is organized temporally
4. **Optimize Parameters**: Use the rounds-per-partition plot to find optimal settings

---

## File Locations

All visualizations are saved in:
```
crates/relay_bp/examples/visualizations/
```

- `partition_quality.png` - Partition strategy comparison
- `decoding_performance.png` - Decoder performance metrics
- `bb_code_structure.png` - Code and partition structure overview
- `partition_structure.png` - Check matrix and detailed partitioning
- `visualization_report.txt` - Text summary of results
- `benchmark_output.txt` - Raw benchmark output
- `parsed_data.json` - Parsed data in JSON format

---

## Generating Visualizations

To regenerate the visualizations:

```bash
cd crates/relay_bp/examples
uv run python3 visualize_fusion.py --no-run
```

The `--no-run` flag uses saved benchmark output. To run a fresh benchmark:

```bash
uv run python3 visualize_fusion.py
```

---

## Technical Details

- **Code**: [[72, 12, 6]] bivariate bicycle code
- **Rounds**: 30 rounds (configurable)
- **Detectors per round**: 72
- **Total detectors**: 2160 (for 30 rounds)
- **Total error variables**: ~87,012
- **Check matrix format**: Sparse CSR (Compressed Sparse Row)
- **Visualization library**: Matplotlib with Seaborn styling

